# 2月技术报告-贾一飞

## 目标与问题

主要目标：

1. 在 QEMU 环境下复现已有的自动测试功能
2. [简化自动测试系统部署流程](#deploy-flow)（对应 [PR #363](https://github.com/arceos-hypervisor/axvisor/pull/363)）
3. [实现多组织共享测试环境](#multi-org-share)（对应 [PR #2](https://github.com/arceos-hypervisor/github-runners/pull/2)、[PR #3](https://github.com/arceos-hypervisor/github-runners/pull/3)、[PR #4](https://github.com/arceos-hypervisor/github-runners/pull/4)、[PR #11](https://github.com/arceos-hypervisor/github-runners/pull/11)）
4. [实现依赖感知的测试目标选择](#dependency-aware)（对应 [PR #369](https://github.com/arceos-hypervisor/axvisor/pull/369)）

主要问题：

1. 现有自动测试系统部署步骤分散在多个脚本和文档中，缺少统一入口，整体流程偏繁琐
2. 多个 GitHub 组织无法共享同一硬件测试环境，缺少防止资源竞争的锁机制，各组织的 Runner 独立运行，无法协调
3. AxVisor 是一个运行在多种硬件平台上的 Hypervisor，其集成测试需要在 QEMU 模拟器和真实开发板上执行。在此之前，每次代码提交（push/PR）都会触发**全部**测试配置（QEMU aarch64、QEMU x86_64、飞腾派、RK3568），即使只修改了一行文档或某个板级驱动也是如此。

## 实现情况（按目标拆分）

<a id="deploy-flow"></a>
### 1) 自动测试系统部署流程简化

- 覆盖范围：脚本 + 文档 + CI。

- **总体目标**  
  - 将“搭一套可用的 AxVisor 集成测试环境”的步骤压缩为“少量脚本 + 固定文档入口”，降低对环境熟悉度的要求，让新同学/新仓库也能按手册快速复现。
- **集中入口脚本**  
  - 通过 `scripts/setup_qemu.sh` 把 QEMU 相关的镜像下载、路径补丁和 `rootfs` 准备整合成单命令入口：开发者只需选择 guest（`arceos` / `linux` / `nimbos`），脚本自动调用 `cargo xtask image download`、检查 kernel/rootfs/BIOS 是否存在，并修补 `configs/vms/*.toml` 中的 `kernel_path` / `bios_path` 字段，最终在仓库 `tmp/` 目录下生成统一可复用的 `rootfs.img`。
- **文档化部署步骤**  
  - 在 `doc/qemu-quickstart_cn.md` 中，将本地依赖安装、Rust 工具链准备、KVM 配置（仅 NimbOS 需要）以及三类 guest 的运行命令，整理成按顺序执行的一份“QEMU 快速上手指南”，并显式指出每一步背后使用的脚本/配置文件，方便读者从文档直接跳到代码。
- **CI 侧一键复现**  
  - 在 `.github/workflows/test-qemu.yml` 中，将 QEMU aarch64 / x86_64 的镜像下载与配置修补逻辑写入统一的 `Download images and patch vm configs` 步骤：在 CI 环境中同样通过 `cargo xtask image download` 与 `sed` 修改 `kernel_path`、`rootfs` 路径，使“本地跑一次 / CI 跑一次”都遵循相同的部署流程，避免两套脚本长期漂移。

<a id="multi-org-share"></a>
### 2) 多组织共享测试环境

- 核心方案：基于 runner-wrapper 与文件锁实现。

- **功能概述**  
  - 在同一台物理主机上，通过 Docker 运行多个 GitHub self-hosted runner 容器，分别注册到不同组织/仓库。
  - 当多个组织需要共享同一块开发板时，使用 `runner-wrapper` + Linux `flock` 文件锁，在 **Job 级别** 串行访问硬件，避免串口、电源等独占资源发生冲突。
- **整体架构**（对应 `docs/runner-wrapper-multi-org-lock.md`）  
  - 每个组织有自己的一套 runner 实例与 `.env` 配置；runner 容器内部启动时并不直接调用 `run.sh`，而是通过 `runner-wrapper.sh` 注入 Job 前后钩子：
    - `pre-job-lock.sh`：Job 开始前获取锁文件（阻塞等待），启动后台 holder 进程持有锁；
    - `post-job-lock.sh`：Job 结束后写入释放标记，holder 进程退出，flock 自动释放锁。
  - 所有共享同一块板子的 runner，通过**相同的锁 ID** 和 **共享的锁目录**（默认 `/tmp/github-runner-locks`）来协调执行：
    - 例如：`board-phytiumpi.lock`、`board-roc-rk3568-pc.lock`，不同板子使用不同锁文件，可并行。
- **多组织共享的具体用法**（对应 `README_CN.md` 的“多组织共享”小节）  
  - 使用 `runner.sh` 生成环境时，需在 `.env` 中为板子设置板子级环境变量（如 `RUNNER_RESOURCE_ID_PHYTIUMPI`、`RUNNER_RESOURCE_ID_ROC_RK3568_PC`）后，板子 runner 才会启用 wrapper 并挂载锁目录；未配置则板子仍使用默认 `run.sh`，不参与文件锁协调。
  - 若要在多组织中共享同一块板，只需要在各自组织的 `.env` 中为该板设置**相同的锁 ID**，例如：
    - 组织 A：`RUNNER_RESOURCE_ID_PHYTIUMPI=board-phytiumpi`
    - 组织 B：`RUNNER_RESOURCE_ID_PHYTIUMPI=board-phytiumpi`
  - 这样，即使两个组织的 runner 容器同时收到访问该板的 Job，也会在锁文件上排队，保证同一时刻只有一个 Job 占用硬件。
  - 详细部署与验证步骤见 `docs/多组织共享Runner使用说明.md`。
- **实现特点与限制**  
  - 不额外降低吞吐：串行来自“硬件只能一次服务一个 Job”的物理约束，方案只是把“无序抢占”变成“有序排队”。
  - 不需要额外中间件：锁基于本地文件系统 `flock`，只依赖 Bash + util-linux，部署简单，可以在现有 CI 环境中直接使用。
  - 不涉及改动 GitHub Actions 的调度逻辑：GitHub 仍按组织维度调度 Job，本仓库通过 runner 容器和 job 钩子在主机侧完成多组织共享与冲突避免。

<a id="dependency-aware"></a>
### 3) 依赖感知的测试目标选择

- 核心方案：基于 xtask 分析与 CI 动态矩阵。

- **功能概述**  
  - 为 AxVisor 引入“依赖感知”的测试目标选择能力：不再对每次 push/PR 盲目触发全部 QEMU/板级测试，而是根据本次变更所影响的 crate 与平台，只运行必要的测试。
  - 通过新的 `cargo xtask affected` 子命令，在本地和 CI 中统一给出“是否跳过全部测试（skip_all）”以及四类测试目标（`qemu_aarch64`、`qemu_x86_64`、`board_phytiumpi`、`board_rk3568`）的布尔开关，实现从“变更 → 受影响 crate → 具体测试目标”的自动映射。
- **核心分析流程**（对应 `doc/dependency-aware-testing.md`）  
  - **阶段 1：变更检测**  
    - 通过 `git diff --name-only <base_ref>` 收集变更文件列表，并过滤掉文档、图片等不会影响代码行为的文件（如 `doc/`、`*.md` 等），支持 `--base origin/main`、`--base HEAD~1` 等多种对比基准。
  - **阶段 2：依赖传播**  
    - 使用 `cargo metadata` 构建 workspace 反向依赖图（例如 `axconfig ← axruntime, axvisor`，`driver ← axvisor`），从直接变更的 crate 出发进行 BFS，得到完整的 `affected_crates` 集合。
  - **阶段 3：目标映射**  
    - 在 `xtask/src/affected.rs` 中维护一组集中管理的规则（当前共 10 条），将“直接变更的 crate / 受影响的 crate / 变更文件路径”映射到四类测试目标上：  
      - 核心模块（如 `axruntime`、`axconfig`）、根构建配置（`Cargo.toml` 等）或 `kernel/` 通用代码变更 → 触发**全部**测试；  
      - 架构相关 HAL、平台 crate（如 `axplat-x86-qemu-q35`）、文件系统 `axfs`、特定 SoC/板级驱动变更 → 精确触发对应的 QEMU 或开发板测试；  
      - 纯文档/图片等变更 → 设置 `skip_all=true`，所有测试跳过。
    - 对于 Rule 2/3 等“全量触发规则”，特意只看“直接修改的 crate”，避免条件编译依赖被 `cargo metadata` 误当成“所有平台同时依赖”而放大测试范围。
- **CI 集成与收益**  
  - 在 `.github/workflows/test-qemu.yml` 与 `test-board.yml` 中，为原有测试 job 新增了一个轻量级的 `detect` job（运行在 `ubuntu-latest` 上），专门负责调用 `cargo xtask affected`：  
    - `detect` job 分析变更范围，将四个测试目标开关和 `skip_all` 写入 `$GITHUB_OUTPUT`；  
    - 后续 `test-qemu` / `test-board` job 根据这些输出动态构建矩阵，只为被标记为 `true` 的目标生成矩阵项；  
    - 当所有目标均为 `false` 且 `skip_all=true` 时，矩阵为空，对应测试 job 会被整体跳过，从而在“只改文档”等场景下完全不占用硬件 Runner。
  - CI 中使用 `actions/cache` 缓存 xtask 的构建产物，使 `detect` job 的额外开销接近零；在多次实验中验证了典型场景：  
    - 只改文档 → 所有测试跳过；  
    - 仅改 aarch64 HAL → 只运行 QEMU AArch64 与两块 ARM 板卡测试；  
    - 仅改飞腾派/Rockchip 相关驱动 → 精确触发对应开发板测试；  
    - 修改核心 runtime / kernel 通用代码 → 仍然触发全量测试，保证安全性。

## 实现总结

1. 围绕 **自动测试系统部署流程简化**，已经形成了统一脚本（`setup_qemu.sh`）、配套文档（`qemu-quickstart_cn.md`）和 CI 侧统一流程（`test-qemu.yml`），降低了本地/CI 搭建 QEMU 测试环境的门槛。
2. 围绕 **多组织共享测试环境**，通过 runner-wrapper + 文件锁机制，在不引入额外中间件的前提下实现了多组织共享同一块开发板且避免资源竞争。
3. 围绕 **依赖感知的测试目标选择**，基于 `cargo xtask affected` 和 GitHub Actions 动态矩阵，实现了按变更范围自动选择 QEMU/板级测试目标，减少无效测试、提升 CI 效率。

## 下一步计划/建议

- 围绕上文三项目标（部署流程简化 / 多组织共享 / 依赖感知测试）持续打磨实现细节，并根据上游 Review 反馈迭代实现。
- 探索将「路径/字符串 → 测试目标」这类简单映射逐步配置化，在保留依赖传播与优先级/短路等强语义逻辑在 Rust 代码中的前提下，降低规则调整的改动成本。
- 完善 `TARGETS` 元数据表和按 `Arch` / `TargetKind` / tags 选择目标的机制，评估是否可以从 `configs/board/*.toml`、`configs/vms/*.toml` 自动生成或校准目标元数据，进一步降低新平台/架构接入时的手工维护成本。

